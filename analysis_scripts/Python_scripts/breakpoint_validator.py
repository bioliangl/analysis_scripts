#!/usr/bin/env python3
"""
This script was generated by Qwen.
Breakpoint validation script for BAM files with split reads analysis.
"""

import pysam
import argparse
from collections import defaultdict
from datetime import datetime


def get_current_time():
    """Get current timestamp"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def parse_coordinate_file(coord_file_path):
    """Parse coordinate file and generate query-reference point pairs"""
    print(f"[{get_current_time()}] Parsing coordinate file...")
    query_ref_pairs = []
    query_pos_to_ref = defaultdict(list)
    
    with open(coord_file_path, "r") as coord_file:
        for line in coord_file:
            fields = line.strip().split("\t")
            if len(fields) >= 8:
                # Extract query and reference points
                chrom_a = fields[0]
                pos1 = int(fields[1])
                pos2 = int(fields[2])
                chrom_c = fields[5]
                pos3 = int(fields[6])
                pos4 = int(fields[7])
                
                # Create two query-reference point pairs
                query_pos1 = f"{chrom_a}:{pos1}"
                ref_pos1 = f"{chrom_c}:{pos4}"  # Mapping: pos1 -> pos4
                
                query_pos2 = f"{chrom_a}:{pos2}"
                ref_pos2 = f"{chrom_c}:{pos3}"  # Mapping: pos2 -> pos3
                
                query_ref_pairs.append((query_pos1, ref_pos1))
                query_ref_pairs.append((query_pos2, ref_pos2))
                
                query_pos_to_ref[query_pos1].append(ref_pos1)
                query_pos_to_ref[query_pos2].append(ref_pos2)
    
    print(f"[{get_current_time()}] Parsed {len(query_ref_pairs)} query-reference pairs")
    return query_ref_pairs, query_pos_to_ref


def collect_reads_info(query_bam_path, query_ref_pairs, query_window=100, min_mapq=30):
    """Phase 1: Collect reads information for all query positions (simplified version, consistent with original logic)"""
    print(f"[{get_current_time()}] Phase 1: Collecting reads information (window size: ±{query_window}bp)...")
    read_to_query_points = {}
    coverage_info = {}
    
    # Group query positions by chromosome to reduce BAM file opening times
    queries_by_chrom = defaultdict(list)
    for query_pos, ref_pos in query_ref_pairs:
        chrom, pos = query_pos.split(":")
        pos = int(pos)
        queries_by_chrom[chrom].append((pos, query_pos, ref_pos))
    
    with pysam.AlignmentFile(query_bam_path, "rb") as bam_file:
        for chrom, query_list in queries_by_chrom.items():
            # Process each query position separately, consistent with original logic
            for pos, query_pos, ref_pos in query_list:
                unique_reads = set()
                split_reads = set()
                
                fetch_start = max(0, pos - query_window)
                fetch_end = pos + query_window
                
                for read in bam_file.fetch(chrom, fetch_start, fetch_end):
                    # Count unique reads (no SA tag and quality qualified)
                    if (not read.has_tag("SA") and 
                        not read.is_secondary and 
                        not read.is_supplementary and 
                        read.mapping_quality >= min_mapq):
                        unique_reads.add(read.query_name)
                    
                    # Collect split reads (with SA tag)
                    if read.has_tag("SA"):
                        split_reads.add(read.query_name)
                
                coverage_info[query_pos] = len(unique_reads)
                
                for read_name in split_reads:
                    if read_name not in read_to_query_points:
                        read_to_query_points[read_name] = []
                    read_to_query_points[read_name].append((query_pos, ref_pos))
    
    total_unique_split_reads = len(read_to_query_points)
    print(f"[{get_current_time()}] Phase 1 completed, collected {total_unique_split_reads} unique split reads")
    return read_to_query_points, coverage_info


def validate_split_reads(ref_bam_path, read_to_query_points, query_ref_pairs, ref_window=15000, min_mapq=30):
    """Phase 2: Directly scan ref BAM file to validate split reads (no temporary files needed)"""
    print(f"[{get_current_time()}] Phase 2: Validating split reads against ref BAM (validation window: ±{ref_window}bp)...")
    validating_counts = {pair: 0 for pair in query_ref_pairs}
    
    split_read_names = set(read_to_query_points.keys())
    
    with pysam.AlignmentFile(ref_bam_path, "rb") as ref_bam:
        for read in ref_bam.fetch(until_eof=True):
            if (read.is_unmapped or read.is_secondary or 
                read.is_supplementary or read.mapping_quality < min_mapq):
                continue
            
            read_name = read.query_name
            if read_name not in split_read_names:
                continue
            
            ref_chrom = read.reference_name
            ref_start = read.reference_start
            
            # Check if this read supports any query-reference pair
            for query_pos, expected_ref_pos in read_to_query_points[read_name]:
                expected_chrom, expected_coord = expected_ref_pos.split(":")
                expected_coord = int(expected_coord)
                
                if (ref_chrom == expected_chrom and 
                    abs(ref_start - expected_coord) <= ref_window):
                    validating_counts[(query_pos, expected_ref_pos)] += 1
    
    print(f"[{get_current_time()}] Phase 2 completed")
    return validating_counts


def save_results(results_file_path, query_ref_pairs, coverage_info, validating_counts):
    """Save results to file"""
    print(f"[{get_current_time()}] Saving results to {results_file_path}...")
    with open(results_file_path, "w") as f:
        f.write("query_pos\tref_pos\tcoverage\tsplit_reads\n")
        for query_pos, ref_pos in query_ref_pairs:
            coverage = coverage_info.get(query_pos, 0)
            validated_splits = validating_counts.get((query_pos, ref_pos), 0)
            f.write(f"{query_pos.replace(':', '-')}\t{ref_pos.replace(':', '-')}\t{coverage}\t{validated_splits}\n")
    print(f"[{get_current_time()}] Processing completed!")


def main():
    """Main function: Coordinate processing phases (simplified optimized version)"""
    parser = argparse.ArgumentParser(description='Breakpoint validation script for BAM files with split reads analysis.')
    parser.add_argument('coord_file_path', help='Path to the coordinate file')
    parser.add_argument('query_bam_path', help='Path to the query BAM file')
    parser.add_argument('ref_bam_path', help='Path to the reference BAM file')
    parser.add_argument('results_file_path', help='Path to the output results file')
    parser.add_argument('--query-window', type=int, default=100, 
                        help='Window size for query position (default: 100)')
    parser.add_argument('--ref-window', type=int, default=15000,
                        help='Window size for reference validation (default: 15000)')
    
    args = parser.parse_args()
    
    # Configuration parameters from command line arguments
    coord_file_path = args.coord_file_path
    query_bam_path = args.query_bam_path
    ref_bam_path = args.ref_bam_path
    results_file_path = args.results_file_path
    
    # Window size configuration
    QUERY_WINDOW = args.query_window  # Query position window size
    REF_WINDOW = args.ref_window      # Reference position validation window size
    
    # Phase 1: Parse coordinate file
    query_ref_pairs, query_pos_to_ref = parse_coordinate_file(coord_file_path)
    
    # Phase 2: Collect reads information (simplified version, consistent with original logic)
    read_to_query_points, coverage_info = collect_reads_info(
        query_bam_path, query_ref_pairs, 
        query_window=QUERY_WINDOW, min_mapq=30
    )
    
    # Phase 3: Directly validate split reads (no temporary files)
    validating_counts = validate_split_reads(
        ref_bam_path, read_to_query_points, query_ref_pairs, 
        ref_window=REF_WINDOW, min_mapq=30
    )
    
    # Phase 4: Save results
    save_results(results_file_path, query_ref_pairs, coverage_info, validating_counts)


if __name__ == "__main__":
    main()